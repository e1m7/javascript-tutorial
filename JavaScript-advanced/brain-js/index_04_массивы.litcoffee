
Нейронные сети на основе библиотеки Brain.js
============================================

Лекция 4: массивы и объекты
===========================

1) Массив это набор элементов одного типа, отличаются по индексу
2) Слои сети === массив данных (удобная абстракция)
3) Данные для тренировки часто даются в виде объектов
4) Объекты надо превратить в массивы и отдать сети


Часть 1: массив данных
======================

    # создали сеть
    const net = new brain.NeuralNetwork({ hiddenLayers: [3] });

    # массив признаков (фичей)
    const colors = [
        { green: 0.2, blue: 0.4 },
        { green: 0.4, blue: 0.6 },
        { red: 0.2, green: 0.8, blue: 0.8 },
        { green: 1, blue: 1 },
        { red: 0.8, green: 1, blue: 1 },
        { red: 1, green: 1, blue: 1 },
        { red: 1, green: 0.8, blue: 0.8 },         # попробовать предсказать
        { red: 1, green: 0.6, blue: 0.6 },
        { red: 1, green: 0.4, blue: 0.4 },
        { red: 1, green: 0.31, blue: 0.31 },
        { red: 0.8 },
        { red: 0.6, green: 0.2, blue: 0.2 }
    ];

    # массив результатов (метки)
    const brightnesses = [
        { dark: 0.8 },
        { neutral: 0.8 },
        { light: 0.7 },
        { light: 0.8 },
        { light: 0.9 },
        { light: 1 },
        { light: 0.8 },                            # попробовать предсказать
        { neutral: 0.7, light: 0.5 },
        { dark: 0.5, neutral: 0.5 },
        { dark: 0.6, neutral: 0.3 },
        { dark: 0.85 },
        { dark: 0.9 }
    ];

    # создали массив входных данных
    const trainingData = [];
    for (let i = 0; i < colors.length; i++) {
        trainingData.push({
            input: colors[i],
            output: brightnesses[i]
        });
    }

    # создали статистику (error, iterations)
    const stat = net.train(trainingData);

    # создали предсказание (dark, neutral, light)
    const answer = net.run({
        red: 0.9
    });

    # вывели статистику и предсказание
    console.log(stat.error, stat.iterations);
    console.log(answer);


Выводы
======

  1) входные данные в виде массива объектов это удобно
  2) для каждого предсказания нужно смотреть ошибку и итерации
  3) оценивать сеть можно по входным данным и данным около них
  4) лучше всего иметь второй правильный набор входных данных (чистый)


Часть 2: инвертированный массив данных
======================================

1) Что будет, если мы поменяем местами входные и выходные данные?
2) Как будет связаны результаты для "одинаковых данных"?

    а) Прямой порядок

        trainingData.push({
            input: colors[i],
            output: brightnesses[i]
        });

        данные={ red: 0,9 }

        ошибка=0.004995001206970897
        итерации=1413
        предсказание= {
            dark: 0.9477242231369019, 
            neutral: 0.03210785984992981, 
            light: 0.0003266345302108675
        }

    б) обратный порядок

        trainingData.push({
            input: brightnesses[i], 
            output: colors[i]
        });

        данные={
            dark: 0.9477242231369019, 
            neutral: 0.03210785984992981, 
            light: 0.0003266345302108675
        }

        ошибка=0.022368937922696855
        итерации=20000
        предсказание ={
            green: 0.12980970740318298, 
            blue: 0.16673190891742706, 
            red: 0.8771334886550903
        }

Выводы
======

    1) нет разницы между признаками и метками, они связаны
    2) можно тренировать сеть: фичи => метки
    3) можно тренировать сеть: метки => фичи

